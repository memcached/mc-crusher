#!/usr/bin/perl
# NOTE: adjust $crush_dir, $out_dir, $server_args and so on to adjust for your
# particular hardware.
# This file is left as an example for running a series of tests with
# mc-crusher using the perl library.
# need to up nofile in /etc/security/limits.conf (65536)

use strict;
use warnings;
use FindBin qw($Bin);
use lib "$Bin/lib";
use Memcached::McCrusher;

$|++;

my $TEST_TYPE = $ARGV[0] or die "supply test type: dram/mm/pmem";

unless ($TEST_TYPE =~ m/^(dram|mm|pmem)$/) {
    die "supply test type: dram/mm/pmem";
}

my $crush_dir = '/home/dormando/mc/mc-crusher/';
my $out_dir = '/home/dormando/output/';
my $key_blob_path = '/tmp/keyblob/';

# settings
my $server_args;
if ($TEST_TYPE eq 'dram') {
    $server_args = '-l 127.0.0.1 -t 48 -c 48000 -m 70000 -o no_lru_crawler -b 4096 -s /tmp/memcached.sock';
} elsif ($TEST_TYPE eq 'pmem') {
    $server_args = '-l 127.0.0.1 -t 48 -c 48000 -m 600000 -o no_lru_crawler -b 4096 -s /tmp/memcached.sock -e /pmem/mc/memc_mmap';
} elsif ($TEST_TYPE eq 'mm') {
    $server_args = '-l 127.0.0.1 -t 48 -c 48000 -m 600000 -o no_lru_crawler -b 4096 -s /tmp/memcached.sock';
}
my $key_count = 125_000_000;
# reserving 24 (and its HT sibling 72) for latency tester.
my $numa_pfx = '/usr/bin/numactl --cpunodebind=1 --membind=1 --physcpubind=25-47,73-95 ';

# FIXME: only require mc-crusher directory?
my $bench = Memcached::McCrusher->new(
    server_args => $server_args,
    server_bin => '/usr/bin/numactl --cpunodebind=0 --membind=0 /home/dormando/mc/memcached/memcached',
    crush_bin => $numa_pfx . $crush_dir . 'mc-crusher',
    balloon_bin => $numa_pfx . $crush_dir . 'balloon',
    latency_bin => '/usr/bin/numactl --cpunodebind=1 --membind=1 --physcpubind=24 ' . $crush_dir . 'latency-sampler',
    sample_bin => $crush_dir . 'bench-sample',
    output_dir => $out_dir,
);

# was period 4. shortening the test duration.
$bench->sample_args(
    runs => 15,
    period => 2,
    stats => ['cmd_get', 'cmd_set', 'get_hits', 'bytes_written', 'bytes_read'],
);

# Test configurations

{
    my $sargs = $server_args;
    my $devline;
    my $type;
    my @tests = ();
    my $thr_max = 25; # 40
    my $thr_step = 1; # 2
    my $threads = 0;
    my $value_size = 256;
    my $key_prefix = 'foobarbazqux';
    my $server_threads = 48;

    my $mget_conf = {
        send => 'ascii_mget',
        recv => 'blind_read',
        conns => $server_threads,
        mget_count => 50,
        key_prefix => $key_prefix,
        #key_file => "$key_blob_path/mget",
        key_count => $key_count
    };
    my $pipe_conf = {
        send => 'ascii_get',
        recv => 'blind_read',
        conns => $server_threads,
        pipelines => 8,
        key_prefix => $key_prefix,
        #key_file => "$key_blob_path/pipe",
        key_count => $key_count
    };
    my $paced_conf = {
        send => 'ascii_get',
        recv => 'blind_read',
        conns => 400,
        pipelines => 50,
        key_prefix => $key_prefix,
        #key_file => "$key_blob_path/paced",
        usleep => 75000,
        key_count => $key_count
    };
    my $pacedsets_conf = {
        send => 'ascii_set',
        recv => 'blind_read',
        conns => 200,
        pipelines => 50,
        key_prefix => $key_prefix,
        usleep => 75000,
        value_size => $value_size,
        key_count => $key_count
    };

    my $test_set_main = sub {
        $bench->server_args($sargs);
        my $sock = $bench->start_memcached();

        print "memc started (main)\n";
        $mget_conf->{key_count} = $key_count;
        $pipe_conf->{key_count} = $key_count;
        $paced_conf->{key_count} = $key_count;
        $pacedsets_conf->{key_count} = $key_count;
 
        $bench->warm(
            prefix => $key_prefix,
            exptime => 0,
            size => $value_size,
            count => $key_count,
            progress => 1,
        );
        $bench->latency_args(
            prefix => $key_prefix,
            key_max => $key_count,
            random => 'unset',
            pace_time => 5000,
            dump_rate => 0
        );

        my $out_base = $out_dir . "main_${TEST_TYPE}_keys_${key_count}";
        #mkdir($key_blob_path);
        #clean_keyblob();
        sleep 2;
        wait_for_settle($bench);
        #$bench->output_dir($key_blob_path);
        #$bench->make_crush_config([$mget_conf]);
        #$bench->start_crush("keygen");

        my $out;
        for (my $count = 1; $count <= $thr_max; $count += $thr_step) {
            my $c = $mget_conf;
            $c->{live_rand} = 1;
            $c->{thread} = $count;
            $out = $out_base . "_threads_${count}_mget_uniform";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand};
            $c->{live_rand_zipf} = 1;
            $c->{zipf_skew} = 0.90;
            $out = $out_base . "_threads_${count}_mget_zipf";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand_zipf};
        }

        #clean_keyblob();
        #$bench->output_dir($key_blob_path);
        #$bench->make_crush_config([$pipe_conf]);
        #$bench->start_crush("keygen");

        for (my $count = 1; $count <= $thr_max; $count += $thr_step) {
            my $c = $pipe_conf;
            $c->{live_rand} = 1;
            $c->{thread} = $count;
            $out = $out_base . "_threads_${count}_pipe_uniform";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand};
            $c->{live_rand_zipf} = 1;
            $c->{zipf_skew} = 0.90;
            $out = $out_base . "_threads_${count}_pipe_zipf";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand_zipf};
        }

        #clean_keyblob();
        #$bench->output_dir($key_blob_path);
        #$bench->make_crush_config([$paced_conf]);
        #$bench->start_crush("keygen");

        my $base_conns = 400;
        for (my $count = 1; $count <= $thr_max; $count += $thr_step) {
            my $c = $paced_conf;
            $c->{conns} = $base_conns;
            $c->{live_rand} = 1;
            $c->{thread} = $count;
            $out = $out_base . "_threads_${count}_paced_uniform";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand};
            $c->{live_rand_zipf} = 1;
            $c->{zipf_skew} = 0.90;
            $out = $out_base . "_threads_${count}_paced_zipf";
            $bench->make_crush_config([$c]);
            run($bench, $out);
            delete $c->{live_rand_zipf};
        }

        #clean_keyblob();
        #$bench->output_dir($key_blob_path);
        #$bench->make_crush_config([$paced_conf, $pacedsets_conf]);
        #$bench->start_crush("keygen");

        for (my $count = 1; $count <= $thr_max; $count += $thr_step) {
            for my $pace (99, 90) {
                my $c = $paced_conf;
                my $c2 = $pacedsets_conf;
                $c->{live_rand} = 1;
                $c2->{live_rand} = 1;
                $c->{thread} = $count;
                $c2->{thread} = $count;
                $c->{conns} = int($base_conns * ($pace / 100));
                $c2->{conns} = $base_conns - $c->{conns};
                $out = $out_base . "_threads_${count}_paced${pace}_uniform";
                $bench->make_crush_config([$c, $c2]);
                run($bench, $out);
                delete $c->{live_rand};
                $c->{live_rand_zipf} = 1;
                $c->{zipf_skew} = 0.90;
                $c2->{live_rand_zipf} = 1;
                $c2->{zipf_skew} = 0.90;
                $out = $out_base . "_threads_${count}_paced${pace}_zipf";
                $bench->make_crush_config([$c, $c2]);
                run($bench, $out);
                delete $c->{live_rand_zipf};
                delete $c2->{live_rand_zipf};
            }
        }

        clean_keyblob();

        $bench->stop_memcached();
    };

    my @key_tests;
    if ($TEST_TYPE =~ m/^(mm|pmem)$/) {
        @key_tests = (125_000_000, 1_000_000_000);
    } else {
        @key_tests = (125_000_000);
    }

    # each iterated test.
    for my $kc (@key_tests) {
        $key_count = $kc;
        $test_set_main->();
        sleep 30;
    }

}

sub clean_keyblob {
    for my $test ('mget', 'pipe', 'paced', 'pacedset') {
        for my $ext ('idx', 'keys') {
            unlink $key_blob_path . "$test.$ext";
        }
    }
}

# TODO: wait for the lru maint thread to settle?
sub wait_for_settle {
    my $bench = shift;
    my $last_count = -1;
    print "lru maintainer thread settling";
    while (1) {
        my $s = $bench->stats();
        # just in case, watch for hash_is_expanding.
        last if ($last_count == $s->{moves_to_cold} && $s->{hash_is_expanding} == 0);
        $last_count = $s->{moves_to_cold};
        print ".";
        sleep 1;
    }
    print "\n";
}

sub run {
    my $bench = shift;
    my $out = shift;
    my $overhead = shift || 5000;
    mkdir($out);
    my $ofile = $out . '/' . 'finished';
    if (-s $ofile) {
        print "skipping $out...\n";
        return;
    }

    $bench->output_dir($out); 
    $bench->start_crush();
    print "crush started!\n";
    $bench->sample_run();
    print "sampling complete\n";
    $bench->stop_crush();
    my $stats = $bench->stats();
    my $slabstats = $bench->stats('slabs');

    open(my $fh, "> $ofile") or die "couldn't open $ofile for writing: $!";
    for my $k (sort keys %$stats) {
        print $fh "STATS $k ", $stats->{$k}, "\n";
    }
    for my $k (sort keys %$slabstats) {
        print $fh "STATS $k ", $slabstats->{$k}, "\n";
    }

    close($fh);
    print "stopped crush... finished $out\n";
    sleep 5;
}

# automatically kills crusher/memcached
